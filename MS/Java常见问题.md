# [Java](https://github.com/mochixuan/Review/blob/788a8c398d/Android/%E5%B8%B8%E8%A7%81%E9%A2%98.md)

##### >> 与 >>>
- >>: 表示右移，如果该数为正，则高位补0，若为负数，则高位补1.
- >>>: 表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0。

##### 哈希表
> 散列的数据结构数据加链表。

##### HashMap原理
- 原理: JDK1.7是数组+链表，JDK1.8数组+链表+红黑树.一个HashMap默认有两个值数据大小和扩容因子。默认是16和0.75。1.查询数组下标: 开始是使用key去调用hashcode再与低16位进行异或运算得到一个Hash值，再与长度做&运算得到数组下标。2. 插入: 判断是否有数值，如果没有则插入，如果有值且链表小与8则插入链表后面，如果大于8则转换为红黑树(转换有些细节)。
- 扩容机制是: JDK1.8是在只要大于12就开始扩容，还有一个情况当值小于64时，且有一个链表值刚好8了，则先扩容。JDK1.7则当大于12切下标冲突时。
- 为什么是8: 作者测试用泊松分布测试过，大部分的时候都不会大于8，所以选择8。正常答案是性能的平衡点，红黑树的结构复杂，查找更快，但要维持结构插入时可能要左右转结构，也是性能消耗。
- HashMap的数组长度一定是2的次幂: 方便扩展，当增加一倍时，之前已经插入的数据的位置只需平易或者加一倍就可以了。
- equals方法需同时重写hashCode方法: 如果2个对象通过equals调用后返回是true，那么这个2个对象的hashCode方法也必须返回同样的int型散列码如果2个对象通过equals返回false，他们的hashCode返回的值允许相同.

##### ConcurrentHashMap: 对节点进行操作，不同节点的操作可以进行并发。Hashtable是对方法加synchromized,所以同一时间只能进行一个操作。

##### LinkedHashMap: HashMap加双向链表实现有序。

##### [红黑树和AVL](https://blog.csdn.net/mmshixing/article/details/51692892 )
- 红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树，avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多。

##### 锁
- synchronized：代码块同步 和 方法同步
- [ReentrantLock(boolean) true时为公平锁](https://www.cnblogs.com/xiaoxi/p/7651360.html)
	- lock: 如果锁处于空闲状态，当前线程将获取到锁。相反，如果锁已经被其他线程持有，将禁用当前线程，直到当前线程获取到锁.
	- tryLock: 如果锁可用，则获取锁，并立即返回true，否则返回false. 该方法和lock()的区别在于，tryLock()只是"试图"获取锁，如果锁不可用，不会导致当前线程被禁用，当前线程仍然继续往下执行代码.
	- unlock: 当前线程将释放持有的锁. 锁只能由持有者释放，如果线程并不持有锁，却执行该方法，可能导致异常的发生.
	- newCondition: 获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将缩放锁。
	- ）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁。
	- synchronized就不是可中断锁，而Lock是可中断锁
- 重入锁：当一个线程得到一个对象后，再次请求该对象锁时是可以再次得到该对象的锁的。
- 公平锁：公平锁可以保证线程按照时间的先后顺序执行，避免饥饿现象的产生。但公平锁的效率比较低，因为要实现顺序执行，需要维护一个有序队列。
- 非公平锁：即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁
- 乐观锁:每次不加锁而是假设修改数据之前其他线程一定不会修改，如果因为修改过产生冲突就失败就重试，直到成功为止.
- 悲观锁.
- CAS: 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作