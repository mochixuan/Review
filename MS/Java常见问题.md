# [Java](https://github.com/mochixuan/Review/blob/788a8c398d/Android/%E5%B8%B8%E8%A7%81%E9%A2%98.md)

##### >> 与 >>>
- >>: 表示右移，如果该数为正，则高位补0，若为负数，则高位补1.
- >>>: 表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0。

##### 哈希表
> 散列的数据结构数据加链表。

##### HashMap原理
- 原理: JDK1.7是数组+链表，JDK1.8数组+链表+红黑树.一个HashMap默认有两个值数据大小和扩容因子。默认是16和0.75。1.查询数组下标: 开始是使用key去调用hashcode再与低16位进行异或运算得到一个Hash值，再与长度做&运算得到数组下标。2. 插入: 判断是否有数值，如果没有则插入，如果有值且链表小与8则插入链表后面，如果大于8则转换为红黑树(转换有些细节)。
- 扩容机制是: JDK1.8是在只要大于12就开始扩容，还有一个情况当值小于64时，且有一个链表值刚好8了，则先扩容。JDK1.7则当大于12切下标冲突时。
- 为什么是8: 作者测试用泊松分布测试过，大部分的时候都不会大于8，所以选择8。正常答案是性能的平衡点，红黑树的结构复杂，查找更快，但要维持结构插入时可能要左右转结构，也是性能消耗。
- HashMap的数组长度一定是2的次幂: 方便扩展，当增加一倍时，之前已经插入的数据的位置只需平易或者加一倍就可以了。
- equals方法需同时重写hashCode方法: 如果2个对象通过equals调用后返回是true，那么这个2个对象的hashCode方法也必须返回同样的int型散列码如果2个对象通过equals返回false，他们的hashCode返回的值允许相同.

##### [红黑树和AVL](https://blog.csdn.net/mmshixing/article/details/51692892 )
- 红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树，avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多。

##### JVM虚拟机和dalvik/art 虚拟机区别
- 执行的文件不同，一个是class，一个是dex
- Dalvik是基于寄存器(寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址)的，而JVM是基于栈的(一个线程一个栈，存放方法、对象的地址、常量).

##### Dalvik VM 与 ART 的不同
- DVM使用JIT来将字节码转换成机器码，效率低。
- ART采用了AOT预编译技术，执行速度更快。
- ART会占用更多的应用安装时间和存储空间。
