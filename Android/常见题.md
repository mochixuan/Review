# 常见题总结
## Java
##### 讲讲volatile
> volatile是轻量级的锁(相比于synchromized)。保证数据的一致性，防止变量在多线程操作时出现数据错乱。java内存管理是CUP处理数据和逻辑时数据是读取和写入高速缓存中的，而高速缓存中的数据是从主存(物理内存)获取。数据被处理时是在高速缓存中，处理完成后更新到主存中。当多个线程处理同一个数据时例如+1，A线程处理完成完成后数据被加一再写入主存，但B线程还是原来的数据。原本加两次1变成1次，而使用volatile时数据被修改后会立刻写入到主存中，导致其他线程的数据无效，重新读取，禁止指定重排序，编译器和处理器在为了更好的性能可能会对指定的编译顺序进行重排序，但不会影响最终的输出。

##### 原子性、可见性、有序性
>- 原子性：是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么就都不执行
>- 可见性是指：当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。
>- 有序性：即程序执行的顺序按照代码的先后顺序执行。

## Android
##### Serializable和Parcelable序列化对象
###### 序列化的目的：
> 在安卓中进程之间的数据传输只支持基本的数据类型，如果要传输复杂的对象，需要在一端进行序列化数据，另一端进行反序列化。序列化只对变量序列化不对对象做序列化。
##### Parcelable
> 实现Parcelable需要写四个方法，构造函数、writeToPacel(Parcel in,int flags)、describeContents()、static CREATOR .
##### Parcelable与Serializable的性能比较
> Oarcelable性能要优于Serializable。主要由于1.后者在序列化时会产生大量的临时数据，由于它使用的是反射机制进行序列化，会频繁的调用GC。而前者是使用IBinder，进程间通信。在读写时前者直接读写，后者是通过IO流的形式，它需要写到磁盘中，这也会造成内存性能消耗，但当数据需要进行磁盘序列化，只能用后者。

##### JS数据类型
> 1 Null 、2 undefined 、 3 boolean 、 4 Number 、5 String 、6 Symbol 、 7 Object