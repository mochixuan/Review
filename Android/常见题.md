# 常见题总结

## 综合
##### 必包
> 闭包就是能够读取其他函数内部变量的函数

## Java
##### 讲讲volatile
>- volatile是轻量级的锁(相比于synchromized)。保证数据的一致性，防止变量在多线程操作时出现数据错乱。java内存管理是CUP处理数据和逻辑时数据是读取和写入高速缓存中的，而高速缓存中的数据是从主存(物理内存)获取。数据被处理时是在高速缓存中，处理完成后更新到主存中。当多个线程处理同一个数据时例如+1，A线程处理完成完成后数据被加一再写入主存，但B线程还是原来的数据。原本加两次1变成1次，而使用volatile时数据被修改后会立刻写入到主存中，导致其他线程的数据无效，重新读取，禁止指定重排序，编译器和处理器在为了更好的性能可能会对指定的编译顺序进行重排序，但不会影响最终的输出。
>- volatile防止指定重排，生产一个对象singleton: 1.给singleton分配内存空间。2. 调用构造函数初始化对象。3. 将singleton指向内存空间(执行这部就不为空)。
>- 无法保证操作的原子性

##### 原子性、可见性、有序性
>- 原子性：是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么就都不执行
>- 可见性是指：当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。
>- 有序性：即程序执行的顺序按照代码的先后顺序执行。


## Android
##### Serializable和Parcelable序列化对象
###### 序列化的目的：
> 在安卓中进程之间的数据传输只支持基本的数据类型，如果要传输复杂的对象，需要在一端进行序列化数据，另一端进行反序列化。序列化只对变量序列化不对对象做序列化。
##### Parcelable
> 实现Parcelable需要写四个方法，构造函数、writeToPacel(Parcel in,int flags)、describeContents()、static CREATOR .
##### Parcelable与Serializable的性能比较
> Oarcelable性能要优于Serializable。主要由于1.后者在序列化时会产生大量的临时数据，由于它使用的是反射机制进行序列化，会频繁的调用GC。而前者是使用IBinder，进程间通信。在读写时前者直接读写，后者是通过IO流的形式，它需要写到磁盘中，这也会造成内存性能消耗，但当数据需要进行磁盘序列化，只能用后者。

##### Activity
- onReStart->onStart
- onPauseA - onCreateB - onStartB - onResumeB - onStopA
- 横竖屏或异常时: (onPause、onSaveInstanceState随机的顺序) - onStop - onDestroy - onCreate - onStart - onRestoreInstanceState - onResume
- FLags三种选择: FLAG_ACTIVITY_NEW_TASK、FLAG_ACTIVITY_SINGLE_TOP、FLAG_ACTIVITY_CLEAR_TOP。
- 四种启动模式 *onNewIntent

##### Searvice
> Service是Android中实现程序后台运行的解决方案，它非常适用于去执行那些不需要和用户交互而且还要求长期运行的任务。Service默认并不会运行在子线程中，它也不运行在一个独立的进程中，它同样执行在UI线程中，因此，不要在Service中执行耗时的操作，除非你在Service中创建了子线程来完成耗时操作

- 生命周期 onCreate(1次) - onStartCommand(n次、每次startService都会调用一次) - onDestroy
- onCreate - onBind - onUnbind - onDestroy
- 关闭服务: stopService() 、stopSelf()、应用管理里关闭服务、内存不足GC清理。
- BIND_AUTO_CREATE:这样就会在service不存在时创建一个

##### BroadcastReceiver
> Binder机制
- 静态注册、动态注册
- 对于动态广播，有注册就必然得有注销，否则会导致内存泄露
- 广播的类型
- 1. 普通广播 2.有序广播 3. 粘性广播(API 21中已经失效) 4. 系统广播 5. App应用内广播(exported属性设置为false、增设相应权限permission)

##### ContentProvider
> 进程间 进行数据交互 & 共享(Binder机制)，开放自己的数据根据需求。

##### Fragment
- 生命周期 onAttach - onCreate - onCreateView - onActivityCreated - onStart - onResume - onPause - onStop - onDestroyView - onDestroy - onDettach

##### Android各个版本新特性
>- 5.0 MD
>- 6.0 安卓权限
>- 7.0 分屏、添加文件权限
>- 8.0 通知栏管理变更
>- 9.0 大刘海

##### Handler
> 非静态的匿名内部类(匿名内部类会隐式的继承一个类或者实现一个接口)会持有外部类的引用。

##### 事件分发
- dispatchTouchEvent 分发事件
- onInterceptTouchEvent 拦截事件只存在ViewGrounp
- onTouchEvent 出来触摸事件
> 当不重写或者调用super时事件从Activity的dispatchTouchEvent再到ViewGropA的的dispatchTouchEvent到onInterceptTouchEvent。再到View的dispatchTouchEvent，onTouchEvent再到ViewGropA的onTouchEvent再到Activity的onTouchEvent。

##### AsyncTask
- 维护了两个线程池：一个SerialExecutor负责用于任务的排队，THREAD_POOL_EXECUTOR用于任务的执行，InternalHandler将线程切回住线程.
- 三个参数1.传入的参数、进度类型、结果没有则可以写Void

##### HandlerThread
> 管理线程Handler(mHandlerThread.getLooper())

##### IntentService

##### IPC
- Intent: 一个进程启动另一个进程可以通过Bundle传输数据。
- 文件共享: SharedPreferences。
- Messenger: Messenger 是一种轻量级的 IPC 方案，它的底层实现是 AIDL ，可以在不同进程中传递 Message 对象，主要是通过创建Messager,通信时使用Binder服务。replyTo。串型，不适合大量并发处理。
- AIDL: 
- ContentProvider
- Socket

##### Android 动画
- 帧动画
- 属性动画
- 补间动画: translate、alpha、scale、rotate

##### 进程
- 前台进程
	- 处于正在与用户交互的activity
	- 正在执行oncreate（），onstart（），ondestroy方法的 service
	- 进程中包含正在执行onReceive（）方法的BroadcastReceiver
	- 调用了startForeground（）方法的service 
	- 与前台activity绑定的service
- 可视进程
	- 不在前台,但仍然可见的activity(调用了onpause但没调用onstop的activity)。
	- 可见activity绑定的service。
- 服务进程
	- 已经启动的service
- 后台进程
	- 不可见的activity（调用onstop（）之后的activity）
- 空进程
	- 任何没有活动的进程

##### Android软引用、弱引用
- SoftReference(软引用): 软引用-->当虚拟机内存不足时，将会回收它指向的对象(图片缓存)。
- WeakReference(弱引用): 随时可能会被垃圾回收器回收，不一定要等到虚拟机内存不足时才强制回收(Handler)。

##### Android 性能优化
- 布局优化
	- 减少布局嵌套(constraint布局)、能用简单的布局就用简单的布局，能用LinearLayout就不用RelativeLayout, RelativeLayout相对复杂。
	- ViewStub: ViewStub提供了按需加载的功能，当需要时才会将ViewStub中的布局加载到内存，提高了程序初始化效率.初始化ViewStub时，如果里面View为不可见不会进行初始化。
- 绘制优化:
	- 自定义View的onDraw不要做大量的操作，有些可以提前初始化的可以构造函数里初始化，例如不要创建局部对象，onDraw调用会特别频繁。
- 内存泄漏优化:
	- leakcanary
	- Android Lint:Lint 是 Android Studio 提供的 代码扫描分析工具，它可以帮助我们发现代码机构 / 质量问题，同时提供一些解决方案，检测内存泄露当然也不在话下，使用也是非常的简单.
	- 非静态类持有外部类的强引用。 
	- Java没有指针，全凭引用来和对象进行关联，通过引用来操作对象。如果一个对象没有与任何引用关联，那么这个对象也就不太可能被使用到了，回收器便是把这些“无任何引用的对象”作为目标，回收了它们占据的内存空间。
- 响应速度优化:
	- 避免在主线程中做耗时操作.
	- Activity如果5秒钟之内无法响应屏幕触摸事件或者键盘输入事件就会出现ANR，而BroadcastReceiver如果10秒钟之内还未执行完操作也会出现ANR。 
- ListView/RecycleView及Bitmap优化:
	-  ViewHolder: 避免了每次在调用getView的时候都去通过findViewById实例化数据。
- 线程优化:
- 其他性能优化的建议:
	- 不要过度使用枚举，枚举占用的内存空间要比整型大。
	- 尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄漏。

##### Android 内存泄露
- 静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。
- 栈区 ：当方法被执行时，方法体内的局部变量都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
- 堆区 ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。

##### 热修复
- Android的类加载器分为两种,PathClassLoader和DexClassLoader，两者都继承自BaseDexClassLoader。
	- PathClassLoader: 用来加载系统类和应用类。
	- DexClassLoader: 用来加载jar、apk、dex文件.加载jar、apk也是最终抽取里面的Dex文件进行加载。


## JS
##### JS数据类型
> 1 Null 、2 undefined 、 3 boolean 、 4 Number 、5 String 、6 Symbol 、 7 Object

##### ES基本方法
- filter 过滤
- splice(index,howmany,item1,.....,itemX):从数组中添加/删除项目，然后返回被删除的项目index:从那个位置开始 howmany 删除的数量，item1...itemX添加什么。
- slice(start,end)可选，可为负，[1,2,3,4]slice(1,2)[2]end不包括该位置[start,end)。
- split(char,num): 分割字符串，char用匹配的单词num保留多少个对象，“abcdabcdabcd”split("cd",2) ["ab","ab"]
- substring(start,end) start开始位置end是结束位置的坐标但不包含结束位置。
- substr(star,num) num为取多少位
- reverse 倒叙
- join 合并
- shift 移除数组的第一个元素
- unshitf()向数组的第一个位置插入元素

##### this 的指向和 call、apply、bind 
- this指向最后调用它的那个对象。
- 箭头函数的 this 始终指向函数定义时的 this，而非执行时（箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值）
- apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。（指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象））同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象
- call: 
- apply、call差别：所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。
- bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。

##### JS异步
> JS是单线程，但浏览器内核可以多线程执行任务。浏览器一般会有三个线程javascript执行线程。GUI线程、事件触发线程。其他的异步任务是在浏览器的其他线程执行的，执行完成后会把结果返回js执行的任务队列的最后。

- promise: 正常执行异步操作，可以then、catch接收结果。
- genrator: redux-saga是使用这个，要自己实现执行器，返回iterator.
- async+awiat: 可以执行多个异步操作。自带执行器，可以try/catch。语法更加语意。await 后面可以是promise也可以是其他的类型的结果。返回结果是promise。
