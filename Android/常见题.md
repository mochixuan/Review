# 常见题总结

## 综合
##### 必包
> 闭包就是能够读取其他函数内部变量的函数

##### 加密
- MD5: MD2、MD3、MD4演变到现在的MD5，不可逆的加密方式。固定长度32、64。常用: 签名。
- DES加密: 对称加密方式，使用的是56的秘钥，现在计算机1天就可以解出来。3DES变种使用3个64位的秘钥进行加密。
- AES加密: (Advanced Encryption Standard)现在比较安全和常用的对称加密方式。
- RSA加密: (三个人名)非对称加密，通过方法生成一对公钥、私钥，性能比较差，比较耗时。1. 使用公钥加密的数据,利用私钥进行解密 2.使用私钥加密的数据,利用公钥进行解密。
- Base64: 编码方式。

##### restful
> REST是一种设计风格而不是标准.

##### 设计模式Java
- 单例模式: 确保全局只有一个实例，并且这个接口提供了唯一的接口去获取这个实例。优点: 节省资源，统一调控，保留一些全局的状态。缺点: 扩张比较麻烦，单例模式持有cotext容易内存泄露。(懒汉式: 调用时实例化对象，一般自己写都是:synchronized双重检验锁。饿汉式: static final第一次加载类到内存中时就会初始化)。
- 抽象工厂模式: 抽出接口。结偶。扩张好点。增加新功能时则要修改抽象工厂。违背了开放封闭原则。
- 建造者模式: Dialog，将一个复杂对象的构建与它的表示分离，根据自己需要进行配置。优点：易扩展。构造者独立。缺点: 产生多余的Builder对象.
- 适配器模式: 更具自己需要配置不同的是适配器，Adapter。
- 代理模式: Android IBinder就是代理，系统AIDL跨进程通信，其他方法通过IBinder调用其他。
- 迭代器模式：遍历.
- 观察者模式: RxJava.EventBus,当被观察者改变时，观察者可以立刻知道，并作出响应。

##### MVP、MVC、MVVM
- MVC:
	- 缺点: Android中View过轻，controller过重，逻辑过多。view和model层没有解藕，controller和view也没有接偶。
	- Android中：视图层(View)：对应于xml布局文件和java代码动态view部分。控制层(controller): 由Activity担当。Model: 根据业务逻辑，建立相关的类主要负责网络请求，数据存储，I/O处理, bean类。大多数人开发Activity即是controller又是model
- MVP: 
	- model层数据模型，bean，数据处理，I/O处理，网络请求。View层(被动试图)是Activity和Fragment。presenter: 将监听或者操作逻辑通过例如单机A发生网络请求的事件通过presenter，再由presenter传输给model，model处理完后将数据传给presneter再进行更新view，控制中心。实现了model和view的接偶，model层不需要知道view的布局，view层也不需要关系model层逻辑。
	- 缺点：多写了一层p层，当逻辑过多时P层的接口将过多。
- MVVM
	- 将Presenter改为ViewModel,View层和Model层实现双向绑定。当View改变时，自动通知ViewModel进行相应的逻辑，Model的改变也会自动映射到view。databinding继承一个baseobserable这个model类为viewmodel。
	- 把一些公共基类定义在baseActivity和basefragement，减少presenter的接口的书写。
	- 缺点: 把View层会比较复杂了，一些逻辑和model处理类的实例化将放在View层。

##### Map
- JS:Map = get、set、has、delete、keys()、values()
- Java: Map = put、get、containsKey、containsValue、remove

## Java
##### 讲讲volatile
>- volatile是轻量级的锁(相比于synchromized)。保证数据的一致性，防止变量在多线程操作时出现数据错乱。java内存管理是CUP处理数据和逻辑时数据是读取和写入高速缓存中的，而高速缓存中的数据是从主存(物理内存)获取。数据被处理时是在高速缓存中，处理完成后更新到主存中。当多个线程处理同一个数据时例如+1，A线程处理完成完成后数据被加一再写入主存，但B线程还是原来的数据。原本加两次1变成1次，而使用volatile时数据被修改后会立刻写入到主存中，导致其他线程的数据无效，重新读取，禁止指定重排序，编译器和处理器在为了更好的性能可能会对指定的编译顺序进行重排序，但不会影响最终的输出。
>- volatile防止指定重排，生产一个对象singleton: 1.给singleton分配内存空间。2. 调用构造函数初始化对象。3. 将singleton指向内存空间(执行这部就不为空)。
>- 无法保证操作的原子性

##### 原子性、可见性、有序性
>- 原子性：是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么就都不执行
>- 可见性是指：当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。
>- 有序性：即程序执行的顺序按照代码的先后顺序执行。


## Android
##### Serializable和Parcelable序列化对象
###### 序列化的目的：
> 在安卓中进程之间的数据传输只支持基本的数据类型，如果要传输复杂的对象，需要在一端进行序列化数据，另一端进行反序列化。序列化只对变量序列化不对对象做序列化。
##### Parcelable
> 实现Parcelable需要写四个方法，构造函数、writeToPacel(Parcel in,int flags)、describeContents()、static CREATOR .
##### Parcelable与Serializable的性能比较
> Oarcelable性能要优于Serializable。主要由于1.后者在序列化时会产生大量的临时数据，由于它使用的是反射机制进行序列化，会频繁的调用GC。而前者是使用IBinder，进程间通信。在读写时前者直接读写，后者是通过IO流的形式，它需要写到磁盘中，这也会造成内存性能消耗，但当数据需要进行磁盘序列化，只能用后者。

##### Activity
- onReStart->onStart
- onPauseA - onCreateB - onStartB - onResumeB - onStopA
- 横竖屏或异常时: (onPause、onSaveInstanceState随机的顺序) - onStop - onDestroy - onCreate - onStart - onRestoreInstanceState - onResume
- FLags三种选择: FLAG_ACTIVITY_NEW_TASK、FLAG_ACTIVITY_SINGLE_TOP、FLAG_ACTIVITY_CLEAR_TOP。
- 四种启动模式 *onNewIntent

##### Searvice
> Service是Android中实现程序后台运行的解决方案，它非常适用于去执行那些不需要和用户交互而且还要求长期运行的任务。Service默认并不会运行在子线程中，它也不运行在一个独立的进程中，它同样执行在UI线程中，因此，不要在Service中执行耗时的操作，除非你在Service中创建了子线程来完成耗时操作

- 生命周期 onCreate(1次) - onStartCommand(n次、每次startService都会调用一次) - onDestroy
- onCreate - onBind - onUnbind - onDestroy
- 关闭服务: stopService() 、stopSelf()、应用管理里关闭服务、内存不足GC清理。
- BIND_AUTO_CREATE:这样就会在service不存在时创建一个

##### BroadcastReceiver
> Binder机制
- 静态注册、动态注册
- 对于动态广播，有注册就必然得有注销，否则会导致内存泄露
- 广播的类型
- 1. 普通广播 2.有序广播 3. 粘性广播(API 21中已经失效) 4. 系统广播 5. App应用内广播(exported属性设置为false、增设相应权限permission)

##### ContentProvider
> 进程间 进行数据交互 & 共享(Binder机制)，开放自己的数据根据需求。

##### Fragment
- 生命周期 onAttach - onCreate - onCreateView - onActivityCreated - onStart - onResume - onPause - onStop - onDestroyView - onDestroy - onDettach

##### Android各个版本新特性
>- 5.0 MD
>- 6.0 安卓权限
>- 7.0 分屏、添加文件权限
>- 8.0 通知栏管理变更
>- 9.0 大刘海

##### Handler
> 非静态的匿名内部类(匿名内部类会隐式的继承一个类或者实现一个接口)会持有外部类的引用。

##### 事件分发
- dispatchTouchEvent 分发事件
- onInterceptTouchEvent 拦截事件只存在ViewGrounp
- onTouchEvent 出来触摸事件
> 当不重写或者调用super时事件从Activity的dispatchTouchEvent再到ViewGropA的的dispatchTouchEvent到onInterceptTouchEvent。再到View的dispatchTouchEvent，onTouchEvent再到ViewGropA的onTouchEvent再到Activity的onTouchEvent。

##### AsyncTask
- 维护了两个线程池：一个SerialExecutor负责用于任务的排队，THREAD_POOL_EXECUTOR用于任务的执行，InternalHandler将线程切回住线程.
- 三个参数1.传入的参数、进度类型、结果没有则可以写Void

##### HandlerThread
> 管理线程Handler(mHandlerThread.getLooper())

##### IntentService

##### IPC
- Intent: 一个进程启动另一个进程可以通过Bundle传输数据。
- 文件共享: SharedPreferences。
- Messenger: Messenger 是一种轻量级的 IPC 方案，它的底层实现是 AIDL ，可以在不同进程中传递 Message 对象，主要是通过创建Messager,通信时使用Binder服务。replyTo。串型，不适合大量并发处理。
- AIDL: 
- ContentProvider
- Socket

##### Android 动画
- 帧动画
- 属性动画
- 补间动画: translate、alpha、scale、rotate

##### 进程
- 前台进程
	- 处于正在与用户交互的activity
	- 正在执行oncreate（），onstart（），ondestroy方法的 service
	- 进程中包含正在执行onReceive（）方法的BroadcastReceiver
	- 调用了startForeground（）方法的service 
	- 与前台activity绑定的service
- 可视进程
	- 不在前台,但仍然可见的activity(调用了onpause但没调用onstop的activity)。
	- 可见activity绑定的service。
- 服务进程
	- 已经启动的service
- 后台进程
	- 不可见的activity（调用onstop（）之后的activity）
- 空进程
	- 任何没有活动的进程

##### Android软引用、弱引用
- SoftReference(软引用): 软引用-->当虚拟机内存不足时，将会回收它指向的对象(图片缓存)。
- WeakReference(弱引用): 随时可能会被垃圾回收器回收，不一定要等到虚拟机内存不足时才强制回收(Handler)。

##### Android 性能优化
- 布局优化
	- 减少布局嵌套(constraint布局)、能用简单的布局就用简单的布局，能用LinearLayout就不用RelativeLayout, RelativeLayout相对复杂。
	- ViewStub: ViewStub提供了按需加载的功能，当需要时才会将ViewStub中的布局加载到内存，提高了程序初始化效率.初始化ViewStub时，如果里面View为不可见不会进行初始化。
- 绘制优化:
	- 自定义View的onDraw不要做大量的操作，有些可以提前初始化的可以构造函数里初始化，例如不要创建局部对象，onDraw调用会特别频繁。
- 内存泄漏优化:
	- leakcanary
	- Android Lint:Lint 是 Android Studio 提供的 代码扫描分析工具，它可以帮助我们发现代码机构 / 质量问题，同时提供一些解决方案，检测内存泄露当然也不在话下，使用也是非常的简单.
	- 非静态类持有外部类的强引用。 
	- Java没有指针，全凭引用来和对象进行关联，通过引用来操作对象。如果一个对象没有与任何引用关联，那么这个对象也就不太可能被使用到了，回收器便是把这些“无任何引用的对象”作为目标，回收了它们占据的内存空间。
- 响应速度优化:
	- 避免在主线程中做耗时操作.
	- Activity如果5秒钟之内无法响应屏幕触摸事件或者键盘输入事件就会出现ANR，而BroadcastReceiver如果10秒钟之内还未执行完操作也会出现ANR。 
- ListView/RecycleView及Bitmap优化:
	-  ViewHolder: 避免了每次在调用getView的时候都去通过findViewById实例化数据。
- 线程优化:
- 其他性能优化的建议:
	- 不要过度使用枚举，枚举占用的内存空间要比整型大。
	- 尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄漏。

##### Android 内存泄露
- 静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。
- 栈区 ：当方法被执行时，方法体内的局部变量都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
- 堆区 ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。

##### 热修复
- Android的类加载器分为两种,PathClassLoader和DexClassLoader，两者都继承自BaseDexClassLoader。
	- PathClassLoader: 用来加载系统类和应用类。
	- DexClassLoader: 用来加载jar、apk、dex文件.加载jar、apk也是最终抽取里面的Dex文件进行加载。

##### RxJava: (链式编程)
- 转换操作符、组合操作符、功能操作符、过滤操作符、条件操作符。
- rxlifecycle: 生命周期管理。
- RxBinding: 防止抖动。
- RxAndroid 就是通过 Handler 来拿到主线程的。

```
private static final class MainHolder {
    static final Scheduler DEFAULT = new HandlerScheduler(new Handler(Looper.getMainLooper()));
    }

    private static final Scheduler MAIN_THREAD = RxAndroidPlugins.initMainThreadScheduler(
        new Callable<Scheduler>() {
            @Override public Scheduler call() throws Exception {
                return MainHolder.DEFAULT;
            }
        }
    );

    public static Scheduler mainThread() {
        return RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);
    }

    public static Scheduler from(Looper looper) {
        if (looper == null) throw new NullPointerException("looper == null");
        return new HandlerScheduler(new Handler(looper));
    }
}
```

```
Observable.create(new ObservableOnSubcribe<T>(){
	subcribe(ObservableEmitter e) {
		
	}
}).doOnSubscribe(new Consumer<Disposable>() {
    @Override
    public void accept(Disposable disposable) throws Exception {
        
	}).subscribe(new Observer<T>(){
		onSubscibe(Disposable e)、onError、onComplete、onNext
	})
```
- doOnSubscribe: 的作用就是只有订阅时才会发送事件可以调用Disposable
- Just(T...): 创建一个被观察者，并发送事件，发送的事件不可以超过10个以上
- fromArray([]): 这个方法和 just() 类似，只不过 fromArray 可以传入多于10个的变量
- fromIterable(List): 遍历数据。
- defer延缓(): 直到被观察者被订阅后才会创建被观察者
- empty() ： 直接发送 onComplete() 事件
- never()：不发送任何事件
- error()：发送 onError() 事件
- map
- flatMap 
- concatMap有序的。
- switchMap: 当源Observable发射一个新的数据项时，如果旧数据项订阅还未完成，就取消旧订阅数据和停止监视那个数据项产生的Observable,开始监视新的数据项
- groupBy 通过key分组。scan、window
- throttleFirst取第一次。
- 组合: 
	- concat: 串行，一个执行完成后，执行另一个只能发生4个 concatArray大于四个，当一个发生错误时就会终止。
	- merge: 并行的,一起完成，只能4个，mergeArray大于4个，当一个发生错误时就会终止。
	- concatArrayDelayError、mergeArrayDelayError
	- zip:会将多个被观察者合并，根据各个被观察者发送事件的顺序一个个结合起来，最终发送的事件数量会与源 Observable 中最少事件的数量一样。
- Scheduler:
	- immediate: 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler.
	- newThread: 总是启用新线程，并在新线程执行操作.
	- io: I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，
            因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程.
	- computation: 计算所使用的 Scheduler。用于循环，这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。
            不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU
	- AndroidSchedulers.mainThread 
	- observeOn 可以调用多次
	- 背压: 一般情况下可以通过subscription.request(n)来请求。
	- BackpressureStrategy: 当事件大于128时例如(1000)
		- ERROR: 这种方式会在出现上下游流速不均衡的时候直接抛出一个异常,这个异常就是著名的MissingBackpressureException .
		- BUFFER: 它没有大小限制 .
		- DROP: 直接把存不下的事件丢弃.
		- LATEST: 只保留最新的事件 .

- 其他观察者模式:
	- Single、SingleObserver 
	- Completable、CompletableObserver
	- Maybe、MaybeObserver

## JS
##### JS数据类型
> 1 Null 、2 undefined 、 3 boolean 、 4 Number 、5 String 、6 Symbol 、 7 Object

##### ES基本方法
- filter 过滤
- splice(index,howmany,item1,.....,itemX):从数组中添加/删除项目，然后返回被删除的项目index:从那个位置开始 howmany 删除的数量，item1...itemX添加什么。
- slice(start,end)可选，可为负，[1,2,3,4]slice(1,2)[2]end不包括该位置[start,end)。
- split(char,num): 分割字符串，char用匹配的单词num保留多少个对象，“abcdabcdabcd”split("cd",2) ["ab","ab"]
- substring(start,end) start开始位置end是结束位置的坐标但不包含结束位置。
- substr(star,num) num为取多少位
- reverse 倒叙
- join 合并
- shift 移除数组的第一个元素
- unshitf()向数组的第一个位置插入元素
- includes数组和字符串都可以是否包含该原属
- concat: 该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。

##### new一个对象步骤
- 1. 创建一个新的空对象 
- 2. 设置新对象的contructor属性为构造函数的名称，设置新对象的__proto__熟悉指向构造函数的prototype对象。
- 3. 使用新对象调用函数，使函数中的this指向新对象。
- 4. 将初始化完毕的新对象地址，赋值给左边的对象。

``` js
function Person() {
	this.name = "mochixuan"
}
var person = {} // var person = new Object();
person.__proto__ = Person.prototype;
Person.call(obj) // {}.构造函数()
```

##### prototype、__proto__、constructor
- __proto__和constructor属性是对象所独有的
- prototype属性是函数所独有的
- 但是由于JS中函数也是一种对象，所以函数也拥有__proto__和constructor属性.
- 如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性.

- 构造函数： JS中所有函数都可以作为构造函数，前提是被new操作符操作.
- 原型对象： 构造函数有一个prototype属性，这个属性会初始化一个原型对象
- 原型链: 一个对象的原型层层递进直到寻找到Object的原型对象，这样的原型和实例所形成的链条叫做原型链。

##### this 的指向和 call、apply、bind 
- this指向最后调用它的那个对象。
- 箭头函数的 this 始终指向函数定义时的 this，而非执行时（箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值）
- apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。（指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象））同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象
- call: 
- apply、call差别：所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。
- bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。

##### JS异步
> JS是单线程，但浏览器内核可以多线程执行任务。浏览器一般会有三个线程javascript执行线程。GUI线程、事件触发线程。其他的异步任务是在浏览器的其他线程执行的，执行完成后会把结果返回js执行的任务队列的最后。

- promise: 正常执行异步操作，可以then、catch接收结果。
- genrator: redux-saga是使用这个，要自己实现执行器，返回iterator.
- async+awiat: 可以执行多个异步操作。自带执行器，可以try/catch。语法更加语意。await 后面可以是promise也可以是其他的类型的结果。返回结果是promise。

## React-Native

##### 生命周期
- 生命周期前 Widget.defaultProps = {设置默认属性}。
- constructor(props)，构造函数,初始化state,访问props,tip: 编写构造函数必须要调用super,调用父类的构造函数，不调无法使用this,这是javascript的限制,反正在没有初始化时调用父类参数。如果不写props则在构造函数里无法使用this.props,无法初始化props，但在构造函数后，会把props传递给实例化后对象的props。
-  componentWillMount(肯) 组件挂载,可以修改state，做一些不消耗性能的操作。
- render 绘制。
- componentDidMount 第一次绘制结束。DOM已经构建完毕，RN是先调用子组件的componentDidMonunt再调用自己的。这时可以和子组件通信。
- componentWillReceviceProps(nextProps): 当属性props被改变时调用。这里可以监控一些props改变更新state。例如登入时。redux时这个状态也很重要。
- shouldComponetUpdate(nextProps,nextState); 返回一个bool是否跟新，这里可以做性能优化，减少一些不必要的重绘。
- componentWillUpdate(nextProps,nextState); 函数调用后新的状态和属性就会被更新上去。
- render: 重绘。
- componentDidUpdate(prevProps,prevState); 刷新结束
- componentWillUnmount(); 卸载阶段，移除监听，释放资源。

##### 新生命周期
>- React v16.3换了新的渲染机制，Fiber。以前渲染过程是同步的，一气呵成。当渲染组件过多，过于复杂时，会让JS线程处于长时间柱塞。让动画，用户操作变得卡顿。Fiber应该是可以中断组件的渲染，当有跟重要的事件要处理时，因为有些刷新可以晚一点刷新。
>- 删除了三个生命周期componentWillMount、componentWillUpdate、componentWillReceiveProps.16.x可以使用UNSAFE_,17后将会被移除。
>- 生命周期: defaultProps 挂载阶段: constructor、static getDerivedStateFromProps(nextprops,prevState) 、render、componentDidMount. 更新：getDerivedStateFromProps(nextProps,prevState)、shouldComponentUpdate(nextProps,nextState)、render、getSnapshotBeforeUpdate(nextProps,prevState)。componentDidUpdate。 componentWillUnmount

- static getDerivedStateFromProps(nextProps,prevState)必须要返回null。render之前会被调用返回的对象会被setState，由于是静态方法无法通过this.props获取props，可以把重要的信息props在state里存一份。
- getSnapshotBeforeUpdate(prevProps, prevState) 在render之后调用,而执行的时候DOM还没有更新。这时候可以返回一个参数给componentDidUpdate第三个参数传入.
- componentDidCatch(error,info) 不影响生命周期。如果render里出现异常，可以抓起组件异常

##### 动画
- Animated
	- createAnimatedComponent
	- View
	- Text
	- Image
	- ScrollView
	- setNativeProps
	
```
Animated.timing(this.state.animatedValue,{
	toValue: 1,   // 透明度最终变为1，即完全不透明
   duration: 10000,
   easing: 
}) //线性
Animated.decay //衰变效果，以一个初始的速度和一个衰减系数逐渐减慢变为0
Animated.spring //弹簧效果，提供了一个简单的弹簧物理模型.
//组合动画
parallel（同时执行）、
sequence（顺序执行）
delay /画延迟，在给定延迟后开始动画。
stagger//按照给定的延时间隔，顺序并行的启动动画。即在前一个动画开始之后，隔一段指定时间开始执行下一个动画，并不关心前一个动画是否已经完成，所以有可能会出现多个动画同时执行的情况。

interpolate({
	inputRange: [],
	outputrange: []// 可以为String,
})

useNativeDriver: true //只能使用非布局的属性，比如transform或者opacity
```

- LayoutAnimation
	- Android要设置UIManager.setLayoutAnimationEnabledExperimental

##### PureComponent:
> 将会对state和props进行浅比较，基本的数据类型直接比较数值是否相等，对象、数组、函数则比较对象的引用。

##### FLatList 优化
>- 继承virtualizedList的属性。
>- 当某行滑出渲染区域之外后，其内部状态将不会保留。请确保你在行组件以外的地方保留了数据。
>- 为了优化内存占用同时保持滑动的流畅，列表内容会在屏幕外异步绘制。这意味着如果用户滑动的速度超过渲染的速度，则会先看到空白的内容。这是为了优化不得不作出的妥协，你可以根据自己的需求调整相应的参数，而我们也在设法持续改进。

- 设置getItemLayout = (length: ,offset: ,index) ,减少测量，节约性能。
- ketExtractor: 设置唯一识别ID，防止数据错乱和频繁刷新。
- extraData: 当额外的数据更改时要刷新flatlist，添加在里面,因为Flatlist继承PureComponent。
- initialNumToRender: 指定一开始渲染的元素数量，最好刚刚够填满一个屏幕，这样保证了用最短的时间给用户呈现可见的内容。注意这第一批次渲染的元素不会在滑动过程中被卸载，这样是为了保证用户执行返回顶部的操作时，不需要重新渲染首批元素。
- bundle拆包：
	- 减少bundle过大的问题。
	- 实现按需加载，而不是一进入就全部加载bundle,将业务代码和三方库+工具库拆开，也方便维护。
	- 在进行热更新的时候减少diff/load比较和加载的效率。
- 原生+RN复杂界面可以实现预加载。 

##### 性能优化
- 首屏白屏: 加入广告页，主要是bundle.js解析和加载需要时间。
- 减少重绘: 
	- 尽量减少不必要的更新，合并更新，shouldComponentUpdate，有些更新频率不大的节目可以使用PureComponent减少不必要的重绘,当界面组件过多时，需要刷新一个组件的属性可以使用setNativeProps(不推荐)，直接修改Native，这样不会调用组件的生命期，减少dom的计算。
	- 在render里尽量不要去写函数，每次渲染都会重新生成函数浪费性能。
- 相应速度优化:
	- 当进入新界面时，或者进行动画，将一些复杂的，耗时的JS操作放在动画结束后或者界面绘制完成后去做，因为JS是单线程的，将重要的UI绘制放在前面完成，反正出现界面卡顿。InteractionManager. runAfterInteractions(()=>{})。
	- requestAnimationFrame:下一帧立刻执行。
	- 减少不必要的动画,使用LayoutAnimation来替代。
- FlatList优化。
- 图片优化。
- immutable。
- 函数式组件：没有生命周期，便于管理，相同输入，相同的组件。

##### Redux
>- 全局的状态共享，全局的状态管理。reducers,store,
>- 三大原则: 单一的数据源(全局只有唯一的一个store)、state只能读唯一能改变state的只有action、用纯函数来控制修改保证可控。

- createStore(allReducers,initialState,middleware)
	- store API: subscribe(监听状态改变)、dispatch、getState(获取状态树)。
- reducer: combineReducers 
- mapStateToProps、MapDIspatchToProps。

##### redux-sage
- genearator *+yield
- all({...}) all([]) // 全部运行完成
- call(fu,obj) //阻塞: fun 即可以是一个 普通 函数，也可以是一个 Generator 函数。
- fork(fn,obj) // 不会柱塞，返回Task。使用cancle(task)
- put() //发生action
- select //获取状态树数据
- take(string or array) 柱塞返回action
- takeEvery() //连续相应 take+fork
- takeLatest() // 只运行最新的 take+fork+cancel
- takeLeading // take,call

##### React-Navigation
- react-native-gesture-handler
- createAppContainer
- createStackNavigator
- createBottomTabNavigator
- createMaterialTopTabNavigator
- createDrawerNavigator
- transitionConfig: ({ screenInterpolator: })
- onTransitionStart.
- onTransitionEnd.

##### UI布局和适配
- dimension、PixleRatio
- justifyContent: flex-start、flex-end、center、space-around、space-between
- alignItems: flex-start、flex-end、center,stretch,baseline
- alignSelf: flex-start、flex-end、center,stretch,baseline、auto
- flexDirection: row,column。
- flexWrap: wrap,nowrap

##### redux-devtools、react-addons-perf

##### immutable
>- 持久化数据结构
>- 结构共享(字典树)节约性能、共享相同的部分，大大提高性能。
>- 惰性操作: 用的时候再调。
>- 开销比较大,toJS很好性能。

##### React Hook
- useState: 
- useEffects: componentDidMount、componentDidUpdate 和 componentWillUnmount 的组合体。放回清理函数可选，在卸载时调用。
- useContext
- useReducer

##### Refs

##### 高阶组件
> 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧，高阶组件是参数为组件，返回值为新组件的函数。redux.

##### 原生组件
- RN绘制是ReactRootView绘制在Activity上调用setContentView(mRootView)。
- extends ReactPackage: 
	- List<NativeModule> createNativeModules(ReactApplicationContext)
	- List<ViewManager> createViewManagers(ReactApplicationContext)
	- NativeModule extends ReactContextBaseJavaModule @ReactMethod
	- ViewManager extends SimpleViewManager<T> @ReactProp
- callback 是异步的，不会立刻被执行。
- promise async+await
- NativeEventEmitter和原生进行通信。
- extends ReactActivity: getMainComponentName放回名字
- Android Application实现ReactNativeHost
- ReactActivityDelegate 核心处理。

##### React-Native 拆包
- 拆包工具: Facebook的metro、携程的moles-packer、google的diff-match-patch
- 将重复的代码或者是工具类和RN三方库打成基础包。
- 优点: 1. 解决jsbundle过大，初始化加载过慢。2.按需求进行加载，提高加载效率。3.提高热更新包diff/load.
- 打包命定
	- entry-file：即入口文件，打包时以该文件作为入口，一步步进行模块分析处理。
	- platform：用于区分打包什么平台的 bundle
	- dev：用于区分 bundle 使用环境，非 dev 时，会对代码进行 minified
	- bundle-output：打包产物输出地址，即打包好的 bundle 存放地址
	- sourcemap-output：打包时生成对应的 sourcemap 文件存放地址，在跟踪查找错误或崩溃时，能帮助开发快速定位到代码
	- assets-dest：bundle 中使用的静态资源文件存放地址
- createModuleIdFactory
- processModuleFilte
- AppRegistry.registerComponent(appName,() => component,)

##### Sentry: 

##### React-Native 原理
- JS引擎上: javascriptCore苹果的，可以和OC进行通信。

##### Code-Push热更新
- staging、production